"""
The Serena Model Context Protocol (MCP) Server
"""

import inspect
import json
import os
import platform
import sys
import traceback
from abc import ABC
from collections import defaultdict
from collections.abc import Callable, Generator, Iterable
from logging import Logger
from pathlib import Path
from typing import TYPE_CHECKING, Any, Self, TypeVar, Union, cast

import yaml
from sensai.util import logging
from sensai.util.logging import FallbackHandler
from sensai.util.string import ToStringMixin, dict_string

from multilspy import SyncLanguageServer
from multilspy.multilspy_config import Language, MultilspyConfig
from multilspy.multilspy_logger import MultilspyLogger
from multilspy.multilspy_types import SymbolKind
from serena.context_mode_config import ContextConfig, ModeConfig, load_context_config, load_mode_config, resolve_tool_activations
from serena import serena_root_path, serena_version
from serena.llm.prompt_factory import PromptFactory
from serena.symbol import SymbolLocation, SymbolManager
from serena.text_utils import search_files
from serena.util.class_decorators import singleton
from serena.util.file_system import scan_directory
from serena.util.inspection import iter_subclasses
from serena.util.shell import execute_shell_command

if TYPE_CHECKING:
    from serena.gui_log_viewer import GuiLogViewerHandler

log = logging.getLogger(__name__)
LOG_FORMAT = "%(levelname)-5s %(asctime)-15s %(name)s:%(funcName)s:%(lineno)d - %(message)s"
TTool = TypeVar("TTool", bound="Tool")
SUCCESS_RESULT = "OK"


def show_fatal_exception_safe(e: Exception) -> None:
    """
    Shows the given exception in the GUI log viewer on the main thread and ensures that the exception is logged or at
    least printed to stderr.
    """
    # Make sure the error is logged (adding a fallback handler which writes to stderr in case there is no other handler)
    fallback_handler = FallbackHandler(logging.StreamHandler(sys.stderr))
    Logger.root.addHandler(fallback_handler)
    log.error(f"Fatal exception: {e}", exc_info=e)

    # attempt to show the error in the GUI
    try:
        # NOTE: The import can fail on macOS if Tk is not available (depends on Python interpreter installation, which uv
        #   used as a base); while tkinter as such is always available, its dependencies can be unavailable on macOS.
        from serena.gui_log_viewer import show_fatal_exception

        show_fatal_exception(e)
    except:
        pass


class SerenaConfigError(Exception):
    pass


class ProjectConfig(ToStringMixin):
    SERENA_MANAGED_DIR = ".serena"
    SERENA_DEFAULT_PROJECT_FILE = "project.yml"

    def __init__(self, config_dict: dict[str, Any], project_name: str, project_root: Path | None = None):
        self.project_name: str = project_name
        try:
            self.language: Language = Language(config_dict["language"].lower())
        except ValueError as e:
            raise ValueError(f"Invalid language: {config_dict['language']}.\nValid languages are: {[l.value for l in Language]}") from e
        if project_root is None:
            project_root = Path(config_dict["project_root"])
        self.project_root: str = str(project_root.resolve())
        self.ignored_paths: list[str] = config_dict.get("ignored_paths", [])
        self.excluded_tools: set[str] = set(config_dict.get("excluded_tools", []))
        self.read_only: bool = config_dict.get("read_only", False)

        if "ignore_all_files_in_gitignore" not in config_dict:
            raise SerenaConfigError(
                f"`ignore_all_files_in_gitignore` key not found in configuration of project '{project_name}'. "
                "Please update your `.yml` configuration file for this project. "
                "It is recommended to set this to `True`."
            )
        self.ignore_all_files_in_gitignore = config_dict["ignore_all_files_in_gitignore"]

        # Raise errors for deprecated keys
        if "ignored_dirs" in config_dict:
            raise SerenaConfigError(
                f"Use of `ignored_dirs` key in configuration of project '{project_name}' deprecated. Please use `ignored_paths` instead. "
                "Note that you can also set `ignore_all_files_in_gitignore` to `True`, which will be enough for most cases."
            )

    @classmethod
    def from_yml(cls, yml_path: Path) -> Self:
        log.info(f"Loading project configuration from {yml_path}")
        try:
            with open(yml_path, encoding="utf-8") as f:
                config_dict = yaml.safe_load(f)
            if yml_path.parent.name == cls.SERENA_MANAGED_DIR:
                project_root = yml_path.parent.parent
                project_name = project_root.name
            else:
                project_root = None
                project_name = yml_path.stem
            return cls(config_dict, project_name=project_name, project_root=project_root)
        except Exception as e:
            raise ValueError(f"Error loading project configuration from {yml_path}: {e}") from e

    def get_serena_managed_dir(self) -> str:
        return os.path.join(self.project_root, self.SERENA_MANAGED_DIR)


@singleton
class SerenaConfig:
    """
    Handles user-defined Serena configuration based on the configuration file
    """

    CONFIG_FILE = "serena_config.yml"

    def __init__(self) -> None:
        config_file = os.path.join(serena_root_path(), self.CONFIG_FILE)
        if not os.path.exists(config_file):
            raise FileNotFoundError(f"Serena configuration file not found: {config_file}")
        with open(config_file, encoding="utf-8") as f:
            try:
                log.info(f"Loading Serena configuration from {config_file}")
                config_yaml = yaml.safe_load(f)
            except Exception as e:
                raise ValueError(f"Error loading Serena configuration from {config_file}: {e}") from e

        # read projects
        self.projects: dict[str, ProjectConfig] = {}
        if "projects" not in config_yaml:
            raise SerenaConfigError("`projects` key not found in Serena configuration. Please update your `serena_config.yml` file.")
        for project_config_path in config_yaml["projects"]:
            project_config_path = Path(project_config_path)
            if not project_config_path.is_absolute():
                project_config_path = Path(serena_root_path()) / project_config_path
            if project_config_path.is_dir():  # assume project file in default location
                project_config_path = project_config_path / ProjectConfig.SERENA_MANAGED_DIR / ProjectConfig.SERENA_DEFAULT_PROJECT_FILE
            if not project_config_path.is_file():
                raise FileNotFoundError(f"Project file not found: {project_config_path}")
            log.info(f"Loading project configuration from {project_config_path}")
            project_config = ProjectConfig.from_yml(project_config_path)
            self.projects[project_config.project_name] = project_config
        self.project_names = list(self.projects.keys())

        self.gui_log_window_enabled = config_yaml.get("gui_log_window", False)
        self.gui_log_window_level = config_yaml.get("gui_log_level", logging.INFO)
        self.enable_project_activation = config_yaml.get("enable_project_activation", True)

    def get_project_configuration(self, project_name: str) -> ProjectConfig:
        if project_name not in self.projects:
            raise ValueError(f"Project '{project_name}' not found in Serena configuration; valid project names: {self.project_names}")
        return self.projects[project_name]


class LinesRead:
    def __init__(self) -> None:
        self.files: dict[str, set[tuple[int, int]]] = defaultdict(lambda: set())

    def add_lines_read(self, relative_path: str, lines: tuple[int, int]) -> None:
        self.files[relative_path].add(lines)

    def were_lines_read(self, relative_path: str, lines: tuple[int, int]) -> bool:
        lines_read_in_file = self.files[relative_path]
        return lines in lines_read_in_file

    def invalidate_lines_read(self, relative_path: str) -> None:
        if relative_path in self.files:
            del self.files[relative_path]


class SerenaAgent:
    def __init__(
        self, 
        project_file_path: str | None = None, 
        project_activation_callback: Callable[[], None] | None = None,
        context_name_or_path: str | None = None,
        mode_names_or_paths: list[str] | None = None
    ):
        """
        :param project_file_path: the configuration file (.yml) of the project to load immediately;
            if None, do not load any project (must use project selection tool to activate a project).
            If a project is provided, the corresponding language server will be started.
        :param project_activation_callback: a callback function to be called when a project is activated.
        :param context_name_or_path: Name or path to a context configuration file
        :param mode_names_or_paths: List of names or paths to mode configuration files
        """
        # obtain serena configuration
        self.serena_config = SerenaConfig()

        # open GUI log window if enabled
        self._gui_log_handler: Union["GuiLogViewerHandler", None] = None  # noqa
        if self.serena_config.gui_log_window_enabled:
            if platform.system() == "Darwin":
                log.warning("GUI log window is not supported on macOS")
            else:
                # even importing on macOS may fail if tkinter dependencies are unavailable (depends on Python interpreter installation
                # which uv used as a base, unfortunately)
                from serena.gui_log_viewer import GuiLogViewer, GuiLogViewerHandler

                log_level = self.serena_config.gui_log_window_level
                if Logger.root.level > log_level:
                    log.info(f"Root logger level is higher than GUI log level; changing the root logger level to {log_level}")
                    Logger.root.setLevel(log_level)
                self._gui_log_handler = GuiLogViewerHandler(GuiLogViewer(title="Serena Logs"), level=log_level, format_string=LOG_FORMAT)
                Logger.root.addHandler(self._gui_log_handler)

        log.info(f"Starting Serena server (version={serena_version()}, process id={os.getpid()}, parent process id={os.getppid()})")
        log.info("Available projects: {}".format(", ".join(self.serena_config.project_names)))

        self.prompt_factory = PromptFactory()
        self._project_activation_callback = project_activation_callback

        # Initialize context and modes
        self.context_config: ContextConfig | None = None
        self.mode_configs: list[ModeConfig] = []
        
        # Load context and modes if provided
        if context_name_or_path:
            self.context_config = load_context_config(context_name_or_path)
            log.info(f"Loaded context: {self.context_config.name}")
        
        if mode_names_or_paths:
            for mode_name_or_path in mode_names_or_paths:
                mode_config = load_mode_config(mode_name_or_path)
                self.mode_configs.append(mode_config)
            log.info(f"Loaded modes: {', '.join([mode.name for mode in self.mode_configs])}")

        # project-specific instances, which will be initialized upon project activation
        self.project_config: ProjectConfig | None = None
        self.language_server: SyncLanguageServer | None = None
        self.symbol_manager: SymbolManager | None = None
        self.memories_manager: MemoriesManager | None = None
        self.lines_read: LinesRead | None = None

        # find all tool classes and instantiate them
        self._all_tools: dict[type[Tool], Tool] = {}
        for tool_class in iter_tool_classes():
            tool_instance = tool_class(self)
            if not self.serena_config.enable_project_activation:
                if tool_class in (GetActiveProjectTool, ActivateProjectTool):
                    log.info(f"Excluding tool '{tool_instance.get_name()}' because project activation is disabled in configuration")
                    continue
            self._all_tools[tool_class] = tool_instance
        
        # Apply context and mode tool settings
        self._active_tools = dict(self._all_tools)
        self._apply_context_and_mode_tool_settings()
        
        log.info(f"Loaded tools ({len(self._all_tools)}): {', '.join([tool.get_name() for tool in self._all_tools.values()])}")
        log.info(f"Active tools ({len(self._active_tools)}): {', '.join(self.get_active_tool_names())}")
